<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Node Editor</title>
    <link rel="stylesheet" href="css/bootstrap.css">
    <style>

    html {
        height: 100%;
    }

    body {
        margin: auto;
        height: 100%;
    }

    .add-node-button {
        cursor: pointer;
    }

    /* Bootstrap */
    .container-full {
        padding: 0 15px;
        margin: 0 auto;
        width: 100%;
        min-height: 100%;
    }

      /* jsplumb start */
      #canvas {
        width: 100%;
        max-height: 100%;
        height: 600px;
        margin: auto;
        position: relative;
      }

      #goo {
        width: 100%;
      }
      .preview {
        padding-left: 15px;
        padding-right: 15px;
        padding-bottom: 15px;
      }

      .demo {
          touch-action:none;
      }

      .w {
          padding: 0;
          position: absolute;
          z-index: 4;
          border: 1px solid black;
          background-color: white;
          font-size: 11px;
          min-width: 100px;
          min-height: 100px;
          border-radius: 4px;
          color: #555;
      }

        .w .out, .w .in {
            cursor: pointer;
            margin: 3px;
        }

        .w .out {
            text-align: right;
        }

      .w .title {
        cursor: move;
        text-align: center;
        padding:5px;
        background-color: #222;
        color: #9d9d9d;
      }

      .w:hover {
          background-color: #ddd;
      }

      .aLabel.jsplumb-hover, .jsplumb-source-hover, .jsplumb-target-hover {
          background-color: #ddd;
      }

      .aLabel {
          background-color: white;
          padding: 3px;
          border: 1px solid black;
          cursor: pointer;
      }

      .ep {
          position: absolute;
          top: 10px;
          right: -30px;
          width: 30px;
          height: 20px;
          background-color: gray;
          cursor: pointer;
      }

      .statemachine-demo .jsplumb-endpoint {
          z-index: 3;
      }

      #opened {
          left: 10em;
          top: 10em;
      }

      #phone1 {
          left: 35em;
          top: 12em;
          width: 7em;
      }

      #inperson {
          left: 12em;
          top: 23em;
      }

      #phone2 {
          left: 28em;
          top: 24em;
      }

      .dragHover {
          border: 2px solid orange;
      }

      path, .jsplumb-endpoint {
        cursor: pointer;
      }

      /* jsplumb end */


    </style>
  </head>
  <body>

    <nav class="navbar navbar-inverse navbar-default navbar-static-top">
      <div class="container-full">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Node Editor</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div id="content" class="container-full"></div>

    <script src="js/jsplumb.js"></script>
    <script src="js/react.js"></script>
    <script src="js/react-dom.js"></script>
    <script src="js/browser.min.js"></script>
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/goo.js"></script>
    <script src="../build/shadergraph.js"></script>
    <script type="text/babel">

        var instance;
        var shader = new ShaderGraph.GraphShader();

        var App = React.createClass({
            getInitialState: function(){
                return {
                    connections: [],
                    nodes: []
                };
            },
            render: function() {
                var nodeTypes = Object.keys(ShaderGraph.Node.classes);

                var nodes = this.state.nodes.map(function(node){
                    // Add some input/output stuff
                    node.inputs = shader.fragmentGraph.getNodeById(node.id).getInputPorts().map(function(key){
                        return {
                            key: key
                        };
                    });
                    node.outputs = shader.fragmentGraph.getNodeById(node.id).getOutputPorts().map(function(key){
                        return {
                            key: key
                        };
                    });
                    return node;
                });
                return (
                    <div className="row">
                        <div className="col-xs-3">
                            <div className="row">
                                <Preview/>
                            </div>
                            <NodeSelectList
                                nodeTypes={nodeTypes}
                                addNode={this.addNode} />
                        </div>
                        <div className="col-xs-9">
                            <NodeEditor
                                nodes={nodes}
                                connect={this.connect}
                                disconnect={this.disconnect}
                                addMainNode={this.addMainNode} />
                        </div>
                    </div>
                );
            },
            addMainNode: function(){
                this.state.nodes.push({
                    id: shader.fragmentGraph.mainNode.id,
                    type: shader.fragmentGraph.mainNode.constructor.type
                });
                this.setState(this.state);
            },
            addNode: function(type){
                var node = new ShaderGraph.Node.classes[type]();
                shader.fragmentGraph.addNode(node);
                var state = this.state;
                state.nodes.push({
                    id: node.id,
                    type: type
                });
                this.setState(state);
            },
            connect: function(nodeA, outputA, nodeB, inputB){
                var nA = shader.fragmentGraph.getNodeById(nodeA);
                var nB = shader.fragmentGraph.getNodeById(nodeB);
                if(!nA) throw new Error('couldnt find node ' + nodeA);
                if(!nB) throw new Error('couldnt find node ' + nodeB);

                if(!nB.canConnect(inputB, nA, outputA)){
                    console.warn(nB.errorMessage);
                    return false;
                }
                nB.connect(inputB, nA, outputA);

                var state = this.state;
                state.connections.push({
                    nodeA: nodeA,
                    nodeB: nodeB,
                    outputA: outputA,
                    inputB: inputB
                });
                this.setState(state);

                return true;
            },
            disconnect: function(nodeA, outputA, nodeB, inputB){
              var state = this.state;
              var connToRemove = state.connections.find(function(conn){
                return (
                    conn.nodeA === nodeA &&
                    conn.nodeB === nodeB &&
                    conn.outputA === outputA &&
                    conn.inputB === inputB
                );
              });
                var idx = state.connections.indexOf(connToRemove);
                if(idx !== -1){
                    state.connections.splice(idx, 1);
                }

                var nA = shader.fragmentGraph.getNodeById(nodeA);
                var nB = shader.fragmentGraph.getNodeById(nodeB);
                nB.disconnect(inputB, nA, outputA);

              this.setState(state);
            }
          });

          var NodeSelectList = React.createClass({
            render: function() {
              var items = this.props.nodeTypes.map(function (type) {
                return (
                    <AddNodeButton key={type} addNode={this.props.addNode} type={type}/>
                );
              }, this);
              return (
                <div className="list-group">
                  {items}
                </div>
              );
            }
          });

          var AddNodeButton = React.createClass({
            render: function() {
              return (
                <a className="list-group-item add-node-button" onClick={this.handleClick}>{this.props.type}</a>
              );
            },
            handleClick: function(){
              this.props.addNode(this.props.type);
            }
          });

          var Preview = React.createClass({
            componentDidMount: function(){
                var gooRunner = new goo.GooRunner({
                    logo: false,
                    useDevicePixelRatio: true
                });
                gooRunner.renderer.setClearColor(0, 0, 0, 1);
                gooRunner.renderer.domElement.id = 'goo';
                ReactDOM.findDOMNode(this).appendChild(gooRunner.renderer.domElement);

                var world = gooRunner.world;
                var shaderDef = shader.buildShader();
                var material = new goo.Material(shaderDef);
                this.entity = world.createEntity(new goo.Sphere(32,32,1), material, function (entity){
                    entity.setRotation(0, -world.time * 0.1, 0);
                }).addToWorld();

                var camera = new goo.Camera();
                var entity = gooRunner.world.createEntity(camera, [0,0,3]).addToWorld();
                world.createEntity(new goo.PointLight(), [-100, 100, 100]).addToWorld();
                console.log('mount preview')
            },
            render: function() {
                this.updateShader();
                return (
                    <div className="preview col-xs-12"></div>
                );
            },
            updateShader: function(){
                if(this.entity){
                    var shaderDef = shader.buildShader();
                    console.log('updateShader', shaderDef.fshader())
                    var material = new goo.Material(shaderDef);
                    this.entity.meshRendererComponent.materials[0] = material;
                }
            }
          });

          var NodeEditor = React.createClass({
            componentDidMount: function(){

                var component = this;

                // setup some defaults for jsPlumb.
                instance = jsPlumb.getInstance({
                    Endpoint: ["Dot", {radius: 0.00001}],
                    Connector:"StateMachine",
                    HoverPaintStyle: {
                      strokeStyle: "#ddd",
                      lineWidth: 2
                    },
                    ConnectionOverlays: [
                        [ "Arrow", {
                            location: 1,
                            id: "arrow",
                            length: 10,
                            foldback: 1
                        } ]
                    ],
                    Container: "canvas"
                });

                instance.registerConnectionType("basic", {
                  anchor:"Continuous",
                  connector:"StateMachine"
                });

                function getConnectionInfo(info){
                    return {
                        nodeA: info.source.parentNode.parentNode.attributes['data-node-id'].value,
                        nodeB: info.target.parentNode.parentNode.attributes['data-node-id'].value,
                        outputA: info.source.innerHTML,
                        inputB: info.target.innerHTML
                    };
                }
                instance.bind("click", function (c) {
                    var info = getConnectionInfo(c);
                    component.props.disconnect(info.nodeA, info.outputA, info.nodeB, info.inputB);
                    instance.detach(c);
                });

                instance.bind("connection", function (c) {
                    var info = getConnectionInfo(c);
                    if(!component.props.connect(info.nodeA, info.outputA, info.nodeB, info.inputB)){
                        instance.detach(c);
                    }
                });

                // suspend drawing and initialise.
                instance.batch(function () {
                    // instance.connect({ source: "opened", target: "phone1", type:"basic" });
                    // instance.connect({ source: "phone1", target: "inperson", type:"basic" });
                    //
                    this.props.addMainNode();

                }.bind(this));
            },
            render: function() {
              var nodes = this.props.nodes;
              return (
                <div className="jtk-demo-canvas canvas-wide statemachine-demo jtk-surface jtk-surface-nopan" id="canvas">
                  {nodes.map(function(node) {
                    return <Node instance={instance} key={node.id} data={node} />;
                  }, this)}
                </div>
              );
            }
          });

          var Node = React.createClass({
            componentDidMount: function(){
                var el = ReactDOM.findDOMNode(this);
                this.props.instance.draggable(el);

                var eps = el.querySelectorAll('.out, .in');
                for(var i=0; i<eps.length; i++){
                    var ep = eps[i];

                    this.props.instance.makeSource(ep, {
                        anchor: "Continuous",
                        connectorStyle: {
                          strokeStyle: "black",
                          lineWidth: 2,
                          outlineColor: "transparent",
                          outlineWidth: 4
                        },
                        maxConnections: 1,
                        connectionType:"basic",
                        onMaxConnections: function (info, e) {
                            console.error("Maximum connections (" + info.maxConnections + ") reached");
                        },
                        extract:{
                            "action": "the-action"
                        }
                    });

                    this.props.instance.makeTarget(ep, {
                        dropOptions: { hoverClass: "dragHover" },
                        anchor: "Continuous",
                        allowLoopback: false
                    });
                }
            },
            render: function() {
                var inputs = this.props.data.inputs.map(function(input){
                    return (
                        <div className="in" key={input.key}>{input.key}</div>
                    );
                });
                var outputs = this.props.data.outputs.map(function(output){
                    return (
                        <div className="out" key={output.key}>{output.key}</div>
                    );
                });
                return (
                    <div className="w" data-node-id={this.props.data.id}>
                        <div className="title">{this.props.data.type}</div>
                        <div className="inputs">
                            {inputs}
                        </div>
                        <div className="outputs">
                            {outputs}
                        </div>
                    </div>
                );
            }
          });

          ReactDOM.render(
            <App />,
            document.getElementById('content')
          );
    </script>
  </body>
</html>